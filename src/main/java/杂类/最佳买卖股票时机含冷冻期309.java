package 杂类;

/**
 * Title: 最佳买卖股票时机含冷冻期309
 * Description: TODO
 *
 * @author zephxu
 * @version V1.0
 * @date 2021-10-07
 */
public class 最佳买卖股票时机含冷冻期309 {
//    public int maxProfit(int[] prices) {
//        /*
//            dp[len][4]
//
//            dp[i][0]    买入股票的状态，今天买入股票或者之前买入股票但没有操作
//            dp[i][1]    卖出股票状态，前几天卖出股票，度过了第二天的冷冻期，但没有操作，保持了到今天的卖出股票状态
//            dp[i][2]    卖出股票状态，今天卖出股票的状态
//            dp[i][3]    冷冻期，今天是冷冻期，只有一天
//
//            1.dp[i][0]
//                (1).今天买入股票，
//                    (一).前一天是度过了冷冻期的卖出股票状态
//                        dp[i][0] = dp[i-1][1] - prices[i]
//                    (二).前一天是冷冻期
//                        dp[i][0] = dp[i-1][3] - prices[i]
//                (2).之前买入股票的状态保持到今天
//                    dp[i][0] = dp[i][0];
//              dp[i][0] = max(dp[i-1][1] - prices[i], dp[i-1][3] - prices[i], dp[i-1][0]);
//
//
//            2.dp[i][1]
//                (1).前一天是冷冻期，今天选择不操作
//                    dp[i][1] = dp[i - 1][3]
//                (2).前一天是度过了冷冻期的卖出股票状态，今天同样选择不操作
//                    dp[i][1] = dp[i - 1][1]
//             dp[i][1] = max (dp[i - 1][3], dp[i - 1][1])
//
//            3.dp[i][2]
//                只有一个操作，昨天是买入股票，今天选择卖出股票
//                    dp[i][2] = dp[i-1][0] + prices[i]
//
//            4.dp[i][3]
//                只有一个操作，昨天是刚卖出股票
//                    dp[i][3] = dp[i-1][2]
//
//            初始化
//                dp[i][0] = -prices[0]   当天买入股票
//                dp[i][1] = 0    不存在第一天是度过冷冻期的卖出状态
//                dp[i][2] = 0    如果当天买入再卖出的状态，相当于什么也不做，因此不讨论当天操作买入、卖出的状态
//                dp[i][3] = 0    不存在第一天是度过冷冻期的状态
//
//            最后除了第一种状态外其余三种状态均能取到最大值
//         */
//        int len = prices.length;
//        int[][] dp = new int[len][4];
//        dp[0][0] = -prices[0];
//        dp[0][1] = 0;
//        dp[0][2] = 0;
//        dp[0][3] = 0;
//
//        for (int i = 1; i < len; i++) {
//            dp[i][0] = Math.max(dp[i-1][0],
//                    Math.max(dp[i-1][1] - prices[i], dp[i-1][3] - prices[i]));
//            dp[i][1] = Math.max(dp[i - 1][3], dp[i - 1][1]);
//            dp[i][2] = dp[i-1][0] + prices[i];
//            dp[i][3] = dp[i-1][2];
//        }
//        return Math.max(dp[len - 1][1],
//                Math.max(dp[len - 1][2], dp[len - 1][3]));
//    }

    public int maxProfit(int[] prices) {
        /*
            dp[len][4]

            dp[i][0]    买入股票的状态，今天买入股票或者之前买入股票但没有操作
            dp[i][1]    卖出股票状态，前几天卖出股票，度过了第二天的冷冻期，但没有操作，保持了到今天的卖出股票状态
            dp[i][2]    卖出股票状态，今天卖出股票的状态
            dp[i][3]    冷冻期，今天是冷冻期，只有一天

            1.dp[i][0]
                (1).今天买入股票，
                    (一).前一天是度过了冷冻期的卖出股票状态
                        dp[i][0] = dp[i-1][1] - prices[i]
                    (二).前一天是冷冻期
                        dp[i][0] = dp[i-1][3] - prices[i]
                (2).之前买入股票的状态保持到今天
                    dp[i][0] = dp[i][0];
              dp[i][0] = max(dp[i-1][1] - prices[i], dp[i-1][3] - prices[i], dp[i-1][0]);


            2.dp[i][1]
                (1).前一天是冷冻期，今天选择不操作
                    dp[i][1] = dp[i - 1][3]
                (2).前一天是度过了冷冻期的卖出股票状态，今天同样选择不操作
                    dp[i][1] = dp[i - 1][1]
             dp[i][1] = max (dp[i - 1][3], dp[i - 1][1])

            3.dp[i][2]
                只有一个操作，昨天是买入股票，今天选择卖出股票
                    dp[i][2] = dp[i-1][0] + prices[i]

            4.dp[i][3]
                只有一个操作，昨天是刚卖出股票
                    dp[i][3] = dp[i-1][2]

            初始化
                dp[i][0] = -prices[0]   当天买入股票
                dp[i][1] = 0    不存在第一天是度过冷冻期的卖出状态
                dp[i][2] = 0    如果当天买入再卖出的状态，相当于什么也不做，因此不讨论当天操作买入、卖出的状态
                dp[i][3] = 0    不存在第一天是度过冷冻期的状态

            最后除了第一种状态外其余三种状态均能取到最大值
         */
        int len = prices.length;
        int[][] dp = new int[2][4];
        dp[0][0] = -prices[0];
        dp[0][1] = 0;
        dp[0][2] = 0;
        dp[0][3] = 0;

        for (int i = 1; i < len; i++) {
            dp[i % 2][0] = Math.max(dp[(i-1) % 2][0],
                    Math.max(dp[(i-1) % 2][1] - prices[i], dp[(i-1) % 2][3] - prices[i]));
            dp[i % 2][1] = Math.max(dp[(i-1) % 2][3], dp[(i-1) % 2][1]);
            dp[i % 2][2] = dp[(i-1) % 2][0] + prices[i];
            dp[i % 2][3] = dp[(i-1) % 2][2];
        }
        return Math.max(dp[(len - 1) % 2][1],
                Math.max(dp[(len - 1) % 2][2], dp[(len - 1) % 2][3]));
    }
}
